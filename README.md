# PostgreSQL Task Queue с моделью аренды (lease)

## Кратко

Этот проект — **сервис очереди задач поверх PostgreSQL** и **SDK для написания воркеров**.

Он предназначен для сценариев, где:

* PostgreSQL уже используется как основная база данных;
* важны корректность, простота и воспроизводимое поведение;
* отдельный брокер сообщений (Kafka / RabbitMQ) избыточен;
* допустима семантика *«как минимум один раз»* при строгом запрете параллельного выполнения одной задачи.

Проект **не является универсальным брокером событий** и не пытается заменить специализированные системы очередей.

---

## Идея проекта

В основе системы лежит **модель аренды (lease)**:

* каждая задача хранится в PostgreSQL;
* воркер берёт задачу в работу **на ограниченное время**;
* пока аренда активна, **только владелец аренды** может завершить задачу;
* если воркер пропал или упал, аренда истекает, и задача становится доступной для повторного выполнения.

Такой подход позволяет:

* исключить параллельное выполнение одной задачи;
* автоматически возвращать «зависшие» задачи в очередь;
* обойтись без ручных блокировок и внешних координаторов.

---

## Гарантии и ограничения

### Гарантии

* у задачи **не более одного активного владельца аренды**;
* задача не теряется при падении воркера или процесса;
* подтверждение результата принимается **только от владельца аренды**;
* поведение системы воспроизводимо и наблюдаемо.

### Ограничения

* возможны повторные выполнения задач (*at-least-once*);
* обработчики задач **обязаны быть идемпотентными**;
* доставка задач осуществляется по модели опроса (polling), а не push.

---

## Состав системы

### 1. Queue Service

HTTP-сервис, отвечающий за:

* приём задач;
* хранение задач в PostgreSQL;
* выдачу задач воркерам с арендой;
* приём подтверждений успеха или ошибки;
* управление повторами, задержками и «мёртвым списком»;
* базовую диагностику и статистику.

Сервис **не знает бизнес-логики задач** и не содержит обработчиков.

---

### 2. SDK

SDK (ориентирован на Go) — **основной интерфейс пользователя системы**.

Он предоставляет:

* клиент для постановки задач;
* воркер с управлением конкурентностью;
* реестр обработчиков по типам задач;
* единый контракт ошибок;
* автоматическую работу с арендой и дедлайнами;
* интеграцию с логами, метриками и трассировкой.

---

### 3. Воркеры

Пользовательские процессы, которые:

* получают задачи из сервиса;
* выбирают обработчик по типу задачи;
* выполняют бизнес-логику;
* сообщают сервису результат выполнения.

Воркеры допускают горизонтальное масштабирование.

---

## Модель задачи

Задача включает следующие атрибуты:

* очередь (queue);
* тип задачи (type, с версионированием);
* полезную нагрузку (payload);
* метки (labels) для трассировки и корреляции;
* приоритет;
* отложенный запуск (run_at);
* счётчик попыток и максимальное число повторов;
* политику повторов;
* информацию об аренде (владелец и срок действия).

---

## Обработчики задач

Обработчик реализует интерфейс вида:

```
Handle(ctx, task_context, payload) -> result
```

Возможные результаты выполнения:

* успешное завершение задачи;
* ошибка с повтором (задача будет выполнена позже);
* фатальная ошибка (задача попадает в «мёртвый список»).

Идемпотентность обработчиков — **обязательное требование**.

В проекте предусмотрены примерные обработчики (email, webhook, запись в БД) как демонстрация рекомендуемых паттернов.

---

## Инженерные принципы

Система проектируется так, чтобы:

* все конкурентные конфликты решались на уровне базы данных;
* операции взятия и подтверждения задач были атомарными;
* поведение можно было проверить тестами;
* нагрузка контролировалась через polling и backoff;
* система была наблюдаемой (логи, метрики, трассировка).

---

## Статус проекта

Проект находится в стадии активного проектирования и реализации.

Планируемые этапы:

1. финализация схемы базы данных;
2. минимальный HTTP API;
3. базовая реализация SDK;
4. примеры обработчиков;
5. тесты инвариантов и конкурентных сценариев.

---

## Для кого этот проект

Проект будет полезен, если вам нужна:

* простая и предсказуемая очередь задач;
* минимальная инфраструктура;
* строгий контроль конкурентного выполнения;
* решение, легко объяснимое и проверяемое.

Если вам нужен универсальный брокер событий или потоковая обработка — этот проект не для вас.
